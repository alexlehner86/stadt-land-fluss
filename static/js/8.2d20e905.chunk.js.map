{"version":3,"sources":["components/ToDashboardButton/ToDashboardButton.tsx","components/ToDashboardButton/ToDashboardButton.module.css","utils/game.utils.ts","models/game.interface.ts","constants/text.constant.ts","components/RejoinRunningGameHint/RejoinRunningGameHint.tsx","components/RejoinRunningGameHint/RejoinRunningGameHint.module.css","utils/error-text.util.ts","components/AddCustomCategory/AddCustomCategory.module.css","components/ChipsArray/ChipsArray.module.css","components/NewGameOptionsPanel/NewGameOptionsPanel.module.css","components/SelectRandomCategories/SelectRandomCategories.module.css","containers/NewGame/NewGame.module.css","components/ChipsArray/ChipsArray.tsx","components/AddCustomCategory/AddCustomCategory.tsx","containers/NewGame/NewGame.tsx","components/NewGameOptionsPanel/NewGameOptionsPanel.tsx","components/SelectRandomCategories/SelectRandomCategories.tsx"],"names":["ToDashboardButton","props","className","styles","button_wrapper","type","color","variant","size","startIcon","onClick","onReturnToDashboard","module","exports","getRandomLetters","numberOfLetters","possibleLetters","length","Error","randomnLetters","lettersToSelectFrom","i","randomnLetter","randomnItem","push","filter","letter","getRandomCategories","numberOfCategories","categoryPool","preselectedCategories","randomCategories","numberOfRandomSelections","categoriesToSelectFrom","category","includes","randomCategory","c","getPlayersInAlphabeticalOrder","players","Array","from","map","data","sort","a","b","name","toLowerCase","getEmptyRoundInputs","numberOfInputs","createAndFillArray","points","STANDARD_POINTS","stars","text","valid","markEmptyPlayerInputsAsInvalid","playerInputs","input","trimmedText","trim","createGameRoundEvaluation","categories","gameRoundEvaluation","Map","forEach","evaluatedPlayer","evaluationsForAllCategories","evaluationForOneCategory","evaluatingPlayer","set","id","calculatePointsForRound","scoringOptions","round","equalAnswers","checkForDuplicates","onlyPlayerWithValidAnswer","playerId","keys","next","value","playerInputsOfPlayer1","get","categoryIndex","calculatePointsForCategory","equalAnswersForCategory","isOnlyPlayerWithValidAnswer","ONLY_ANSWER_POINTS","awardSameWordPoints","isDuplicateOfOtherPlayersInput","SAME_WORD_POINTS","otherPlayersIds","isOnlyPlayer","playerInputText","getCleanText","some","otherPlayersInput","getMinNumberOfInvalids","numberOfPlayers","getNumberOfInvalids","evaluations","count","markedAsValid","getRejectingPlayers","rejectingPlayers","playerInfo","applyValidFlagAndCreativeStarsToPoints","creativeAnswersExtraPoints","EXTRA_POINTS","calculateGameResults","allPlayers","gameRounds","gameResultForPlayer","inputs","reduce","total","item","allPoints","gameResultsMap","Object","playerNames","groupedGameResults","uniq","createHallOfFameData","gameConfig","hallOfFameData","playerInput","playerName","GameOption","EndRoundMode","GAME_ID_LABEL","NUMBER_OF_CATEGORIES_LABEL","NUMBER_OF_ROUNDS_LABEL","PLAYER_NAME_LABEL","RejoinRunningGameHintContext","RejoinRunningGameHint","condition","context","hintText","hint_text","component","rejoin_game_button","rejoinRunningGame","getInvalidNameError","getInvalidGameIdError","getInvalidRoundsError","MIN_NUMBER_OF_ROUNDS","MAX_NUMBER_OF_ROUNDS","getTooFewCategoriesError","MIN_NUMBER_OF_CATEGORIES","getTooManyLettersExcludedError","numberOfRounds","makePluralIfCountIsNotOne","maxNumberToExclude","STANDARD_ALPHABET","ChipType","CustomCategoryDialog","onClose","open","useState","categoryInput","setCategoryInput","validateInputs","setValidateInputs","isCategoryInputInvalid","handleClose","Dialog","onEnter","onSubmit","event","preventDefault","stopPropagation","trimmedCategoryInput","dialog_min_width","noValidate","autoComplete","DialogContent","DialogContentText","htmlFor","TextField","autoFocus","margin","fullWidth","required","error","helperText","inputProps","onChange","target","DialogActions","Button","AddCustomCategory","setOpen","Fragment","IconButton","add_category_button","title","aria-label","newCategory","addCustomCategory","CategoryArray","useStyles","makeStyles","theme","createStyles","root","display","justifyContent","flexWrap","padding","spacing","ChipsArray","classes","role","chipsArray","chip","index","Chip","label","chip_label","chipType","undefined","icon","removeChip","NewGameOptionsPanel","Accordion","AccordionSummary","expandIcon","aria-controls","AccordionDetails","FormGroup","FormControlLabel","control","Checkbox","checked","handleGameOptionChange","GAME_OPTION_LABEL","Divider","FormControl","FormLabel","options_label","row","letterIndex","lettersToExclude","handleLetterToExcludeChange","fontSize","SelectRandomCategoriesDialog","checkboxLabelClasses","isNumberOfCategoriesInputValid","setIsNumberOfCategoriesInputValid","numberOfCategoriesInput","setNumberOfCategoriesInput","retainSelection","setRetainSelection","numberOfCategoriesAriaLabel","maxNumberOfCategories","numberOfCategoriesVisibleLabel","dialog_title","min","max","SelectRandomCategories","random_categories_button","selectCategoriesRandomly","NewGame","state","a11yMessageAssertive","a11yMessagePolite","availableCategories","AVAILABLE_CATEGORIES","durationOfCountdown","DEFAULT_DURATION_OF_COUNTDOWN","endRoundMode","allPlayersSubmit","isNumberOfRoundsInputValid","isSnackbarOpen","STANDARD_EXCLUDED_LETTERS","nameInput","numberOfRoundsInput","DEFAULT_NUMBER_OF_ROUNDS","selectedCategories","STANDARD_CATEGORIES","snackBarMessage","submitButton","handleNameInputChange","setState","handleNumberOfRoundsInputChange","handleCountdownInputChange","newLettersToExclude","l","handleUseCountdownChange","setTimeout","updateCategoryArrays","chipToRemove","removeFromArray","newSelectedCategories","newAvailableCategories","selected","scrollToAndFocusSubmitButton","current","scrollIntoView","focus","handleSubmit","isReadyToStartGame","startNewGame","alertUser","message","handleSnackBarClose","idCreationTimestamp","playerIdCreationTimestamp","gameId","uuidv4","removeAllDataOfRunningGameFromLocalStorage","setPlayerInfoInLocalStorage","setRunningGameInfoInLocalStorage","convertDateToUnixTimestamp","Date","isPlayerAdmin","onSetGameData","letters","xor","isRejoiningGame","isAdmin","history","onPrepareRejoiningGame","returnToDashboard","React","createRef","playerNameAriaLabel","PLAYER_NAME_MAX_LENGTH","playerNameVisibleLabel","numberOfRoundsAriaLabel","numberOfRoundsVisibleLabel","this","isNameInvalid","isNumberOfRoundsInvalid","isNumberOfCategoriesInvalid","areTooManyLettersExcluded","tooFewCategoriesError","FormHelperText","too_few_categories_error","tooManyLettersExcludedError","too_many_letters_excluded_error","noCategoriesSelected","no_categories_hint","noCategoriesAvailable","newGameForm","maxLength","custom_fieldset","custom_legend","RadioGroup","radio_group","Radio","firstPlayerSubmits","countdown_wrapper","countdownEnds","Input","countdown_input","disabled","MIN_DURATION_OF_COUNTDOWN","info_text","tabIndex","selected_categories_wrapper","custom_fieldset_error","jump_to_end_button","jump_to_end_button_icon","available","ref","rejoinRunningGameElement","newgame","SectionHeader","Snackbar","anchorOrigin","vertical","horizontal","autoHideDuration","SnackbarContent","alert_snackbar","aria-live","clearOnUnmount","prevProps","Component","connect","dispatch","prepareRejoiningGame","payload","setDataForNewGame"],"mappings":"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","file":"static/js/8.2d20e905.chunk.js","sourcesContent":["import { Button } from '@material-ui/core';\r\nimport ExitToAppIcon from '@material-ui/icons/ExitToApp';\r\nimport React from 'react';\r\n\r\nimport styles from './ToDashboardButton.module.css';\r\n\r\ninterface ToDashboardButtonProps {\r\n    onReturnToDashboard: () => any;\r\n}\r\n\r\nconst ToDashboardButton: React.FunctionComponent<ToDashboardButtonProps> = props => {\r\n    return (\r\n        <div className={styles.button_wrapper}>\r\n            <Button\r\n                type=\"button\"\r\n                color=\"default\"\r\n                variant=\"contained\"\r\n                size=\"large\"\r\n                startIcon={<ExitToAppIcon />}\r\n                onClick={props.onReturnToDashboard}\r\n            >Dashboard</Button>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default ToDashboardButton;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"button_wrapper\":\"ToDashboardButton_button_wrapper__1EtAB\"};","import { some, uniq } from 'lodash';\r\nimport randomnItem from 'random-item';\r\n\r\nimport { ONLY_ANSWER_POINTS, SAME_WORD_POINTS, STANDARD_POINTS } from '../constants/game.constant';\r\nimport { Collection } from '../models/collection.interface';\r\nimport { GameConfigScoringOptions, HallOfFameEntry, PlayerInput } from '../models/game.interface';\r\nimport { PlayerInfo } from '../models/player.interface';\r\nimport { EXTRA_POINTS } from './../constants/game.constant';\r\nimport {\r\n    GameConfig,\r\n    GameResultsGroup,\r\n    GameRound,\r\n    GameRoundEvaluation,\r\n    PlayerInputEvaluation,\r\n} from './../models/game.interface';\r\nimport { createAndFillArray, getCleanText } from './general.utils';\r\n\r\n/**\r\n* Returns an array of randomly selected, unique letters.\r\n*/\r\nexport const getRandomLetters = (numberOfLetters: number, possibleLetters: string[]): string[] => {\r\n    if (numberOfLetters > possibleLetters.length) {\r\n        throw new Error('Cannot create more randomn unique letters than the number of possibleLetters provided!');\r\n    }\r\n    const randomnLetters: string[] = [];\r\n    let lettersToSelectFrom = [...possibleLetters];\r\n    for (let i = 0; i < numberOfLetters; i++) {\r\n        const randomnLetter = randomnItem(lettersToSelectFrom);\r\n        randomnLetters.push(randomnLetter);\r\n        lettersToSelectFrom = lettersToSelectFrom.filter(letter => letter !== randomnLetter);\r\n    }\r\n    return randomnLetters;\r\n};\r\n\r\n/**\r\n* Returns an array of randomly selected categories.\r\n*/\r\nexport const getRandomCategories = (\r\n    numberOfCategories: number, categoryPool: string[], preselectedCategories: string[]\r\n): string[] => {\r\n    const randomCategories: string[] = [...preselectedCategories];\r\n    const numberOfRandomSelections = numberOfCategories - preselectedCategories.length;\r\n    let categoriesToSelectFrom = categoryPool.filter(category => !preselectedCategories.includes(category));\r\n    for (let i = 0; i < numberOfRandomSelections; i++) {\r\n        const randomCategory = randomnItem(categoriesToSelectFrom);\r\n        randomCategories.push(randomCategory);\r\n        categoriesToSelectFrom = categoriesToSelectFrom.filter(c => c !== randomCategory);\r\n    }\r\n    return randomCategories;\r\n};\r\n\r\nexport const getPlayersInAlphabeticalOrder = (players: Map<string, PlayerInfo>): PlayerInfo[] => {\r\n    const playerInfoArray = Array.from(players).map(data => data[1]);\r\n    return playerInfoArray.sort((a, b) => {\r\n        if (a.name.toLowerCase() < b.name.toLowerCase()) { return -1; }\r\n        if (a.name.toLowerCase() > b.name.toLowerCase()) { return 1; }\r\n        return 0;\r\n    });\r\n};\r\n\r\n/**\r\n * Returns an array of PlayerInput objects with empty strings and default settings (standard points, stars=0, valid=true).\r\n */\r\nexport const getEmptyRoundInputs = (numberOfInputs: number): PlayerInput[] => {\r\n    return createAndFillArray<PlayerInput>(numberOfInputs, { points: STANDARD_POINTS, stars: 0, text: '', valid: true });\r\n};\r\n\r\n/**\r\n* Checks each PlayerInput object whether it contains text.\r\n* If text string is empty, valid is set to false, otherwise to true.\r\n* The text is also trimmed in order to support correct scoring (finding duplicates).\r\n*/\r\nexport const markEmptyPlayerInputsAsInvalid = (playerInputs: PlayerInput[]): PlayerInput[] => {\r\n    return playerInputs.map(input => {\r\n        const trimmedText = input.text.trim();\r\n        return { ...input, text: trimmedText, valid: trimmedText !== '' };\r\n    });\r\n};\r\n\r\nexport const createGameRoundEvaluation = (players: Map<string, PlayerInfo>, categories: string[]): GameRoundEvaluation => {\r\n    const gameRoundEvaluation = new Map<string, PlayerInputEvaluation[]>();\r\n    players.forEach(evaluatedPlayer => {\r\n        const evaluationsForAllCategories: PlayerInputEvaluation[] = [];\r\n        categories.forEach(() => {\r\n            const evaluationForOneCategory: PlayerInputEvaluation = new Map<string, boolean>();\r\n            players.forEach(evaluatingPlayer => {\r\n                // The default evaluation for each input is valid (= true).\r\n                evaluationForOneCategory.set(evaluatingPlayer.id, true);\r\n            });\r\n            evaluationsForAllCategories.push(evaluationForOneCategory);\r\n        });\r\n        gameRoundEvaluation.set(evaluatedPlayer.id, evaluationsForAllCategories);\r\n    });\r\n    return gameRoundEvaluation;\r\n};\r\n\r\n/**\r\n * Calculates the points for the round's inputs according to the active scoring options.\r\n * `equalAnswers`: The answers manually marked equal by the admin for each category (key = index).\r\n */\r\nexport const calculatePointsForRound = (\r\n    scoringOptions: GameConfigScoringOptions, round: GameRound, equalAnswers: Map<number, string[]>\r\n): void => {\r\n    if (!scoringOptions.checkForDuplicates && !scoringOptions.onlyPlayerWithValidAnswer) { return; }\r\n    const playerId = round.keys().next().value;\r\n    const playerInputsOfPlayer1 = round.get(playerId) as PlayerInput[];\r\n    // Loop through all categories.\r\n    for (let categoryIndex = 0; categoryIndex < playerInputsOfPlayer1.length; categoryIndex++) {\r\n        calculatePointsForCategory(scoringOptions, round, categoryIndex, equalAnswers.get(categoryIndex));\r\n    }\r\n};\r\n\r\n/**\r\n * Calculates the points for the round's inputs for one category according to the active scoring options.\r\n * `equalAnswersForCategory`: The answers manually marked equal by the admin.\r\n */\r\nexport const calculatePointsForCategory = (\r\n    scoringOptions: GameConfigScoringOptions, round: GameRound, categoryIndex: number, equalAnswersForCategory: string[] = []\r\n): void => {\r\n    if (!scoringOptions.checkForDuplicates && !scoringOptions.onlyPlayerWithValidAnswer) { return; }\r\n    Array.from(round.keys()).forEach(playerId => {\r\n        const playerInputs = round.get(playerId) as PlayerInput[];\r\n        // Only check valid inputs.\r\n        if (playerInputs[categoryIndex].valid) {\r\n            if (scoringOptions.onlyPlayerWithValidAnswer && isOnlyPlayerWithValidAnswer(playerId, round, categoryIndex)) {\r\n                playerInputs[categoryIndex].points = ONLY_ANSWER_POINTS;\r\n            } else {\r\n                const awardSameWordPoints = scoringOptions.checkForDuplicates\r\n                    && isDuplicateOfOtherPlayersInput(playerId, round, categoryIndex, equalAnswersForCategory);\r\n                playerInputs[categoryIndex].points = awardSameWordPoints ? SAME_WORD_POINTS : STANDARD_POINTS;\r\n            }\r\n        }\r\n    });\r\n};\r\n\r\nexport const isOnlyPlayerWithValidAnswer = (playerId: string, round: GameRound, categoryIndex: number): boolean => {\r\n    const otherPlayersIds = Array.from(round.keys()).filter(id => id !== playerId);\r\n    let isOnlyPlayer = true;\r\n    otherPlayersIds.forEach(id => isOnlyPlayer = isOnlyPlayer && !(round.get(id) as PlayerInput[])[categoryIndex].valid);\r\n    return isOnlyPlayer;\r\n};\r\n\r\n/**\r\n * Returns true if a duplicate for playerId's input was found.\r\n * `equalAnswers`: The answers manually marked equal by the admin.\r\n */\r\nexport const isDuplicateOfOtherPlayersInput = (\r\n    playerId: string, round: GameRound, categoryIndex: number, equalAnswers: string[]\r\n): boolean => {\r\n    const playerInputText = getCleanText((round.get(playerId) as PlayerInput[])[categoryIndex].text);\r\n    const otherPlayersIds = Array.from(round.keys()).filter(id => id !== playerId);\r\n    return equalAnswers.includes(playerInputText) || some(otherPlayersIds, id => {\r\n        const otherPlayersInput = (round.get(id) as PlayerInput[])[categoryIndex];\r\n        return otherPlayersInput.valid && playerInputText === getCleanText(otherPlayersInput.text);\r\n    });\r\n};\r\n\r\n/**\r\n * Determines the minimum number of players that need to mark a player's input as invalid\r\n * for the input text to be set to invalid and not count as a point for the player.\r\n */\r\nexport const getMinNumberOfInvalids = (numberOfPlayers: number): number => numberOfPlayers <= 3 ? 1 : 2;\r\n\r\n/**\r\n * Returns how many players marked the input as invalid.\r\n */\r\nexport const getNumberOfInvalids = (evaluations: PlayerInputEvaluation): number => {\r\n    let count = 0;\r\n    evaluations.forEach(markedAsValid => count = markedAsValid ? count : count + 1);\r\n    return count;\r\n};\r\n\r\n/**\r\n * Returns the players that marked the input as invalid in alphabetical order. Parameters:\r\n * - evaluations: Evaluations of all players for one player's input for one category.\r\n * - players: All players taking part in the running game of \"Stadt-Land-Fluss\".\r\n */\r\nexport const getRejectingPlayers = (evaluations: PlayerInputEvaluation, players: Map<string, PlayerInfo>): PlayerInfo[] => {\r\n    const rejectingPlayers = new Map<string, PlayerInfo>();\r\n    evaluations.forEach((markedAsValid, playerId) => {\r\n        if (!markedAsValid) {\r\n            const playerInfo = players.get(playerId);\r\n            if (playerInfo) {\r\n                rejectingPlayers.set(playerId, playerInfo);\r\n            }\r\n        }\r\n    });\r\n    return getPlayersInAlphabeticalOrder(rejectingPlayers);\r\n};\r\n\r\n/**\r\n * Adds extra points for \"creative answer\" stars if scoring option is active\r\n * and sets invalid answer's points to zero.\r\n */\r\nexport const applyValidFlagAndCreativeStarsToPoints = (scoringOptions: GameConfigScoringOptions, round: GameRound): void => {\r\n    round.forEach(playerInputs => {\r\n        playerInputs.forEach(input => {\r\n            if (!input.valid) {\r\n                input.points = 0;\r\n            } else if (scoringOptions.creativeAnswersExtraPoints && input.stars > 0) {\r\n                input.points += EXTRA_POINTS * input.stars;\r\n            }\r\n        });\r\n    });\r\n};\r\n\r\n/**\r\n * Calculates game results, groups them by points and sorts them in descending order.\r\n */\r\nexport const calculateGameResults = (allPlayers: Map<string, PlayerInfo>, gameRounds: GameRound[]): GameResultsGroup[] => {\r\n    // 1. Calculate the points for each player.\r\n    const gameResultForPlayer: Collection<{ name: string, points: number }> = {};\r\n    allPlayers.forEach((playerInfo, playerId) => gameResultForPlayer[playerId] = { name: playerInfo.name, points: 0 });\r\n    gameRounds.forEach(round => {\r\n        round.forEach((inputs, playerId) => gameResultForPlayer[playerId].points += inputs.reduce((total, item) => total + item.points, 0));\r\n    });\r\n    // 2. Group the results by points.\r\n    const allPoints: number[] = [];\r\n    const gameResultsMap = new Map<number, string[]>();\r\n    Object.keys(gameResultForPlayer).forEach(playerId => {\r\n        const { name, points } = gameResultForPlayer[playerId];\r\n        allPoints.push(points);\r\n        const playerNames = gameResultsMap.get(points) || [];\r\n        gameResultsMap.set(points, [...playerNames, name]);\r\n    });\r\n    // 3. Return the results groups sorted in descending order.\r\n    const groupedGameResults: GameResultsGroup[] = [];\r\n    uniq(allPoints)\r\n        .sort((a, b) => b - a)\r\n        .forEach(points => groupedGameResults.push({ playerNames: (gameResultsMap.get(points) as string[]).sort(), points }));\r\n    return groupedGameResults;\r\n};\r\n\r\n/**\r\n * Creates a list of entries for the \"Hall of Fame\", the list of answers that received \"creative answer\" stars.\r\n */\r\nexport const createHallOfFameData = (allPlayers: Map<string, PlayerInfo>, gameConfig: GameConfig, gameRounds: GameRound[]): HallOfFameEntry[] => {\r\n    const hallOfFameData: HallOfFameEntry[] = [];\r\n    gameRounds.forEach(round => {\r\n        round.forEach((playerInputs, playerId) => {\r\n            const playerInfo = allPlayers.get(playerId) as PlayerInfo;\r\n            playerInputs.forEach((playerInput, categoryIndex) => {\r\n                if (playerInput.valid && playerInput.stars > 0) {\r\n                    hallOfFameData.push({\r\n                        category: gameConfig.categories[categoryIndex],\r\n                        playerName: playerInfo.name,\r\n                        text: playerInput.text\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    });\r\n    return hallOfFameData;\r\n};\r\n","export enum GameOption {\r\n    checkForDuplicates = 'checkForDuplicates',\r\n    creativeAnswersExtraPoints = 'creativeAnswersExtraPoints',\r\n    onlyPlayerWithValidAnswer = 'onlyPlayerWithValidAnswer',\r\n}\r\n\r\nexport interface GameConfigScoringOptions {\r\n    [GameOption.checkForDuplicates]: boolean;\r\n    [GameOption.creativeAnswersExtraPoints]: boolean;\r\n    [GameOption.onlyPlayerWithValidAnswer]: boolean;\r\n}\r\n\r\nexport enum EndRoundMode {\r\n    /**\r\n     * All players have to click \"Finish round\" to end the round.\r\n     */\r\n    allPlayersSubmit = 'allPlayers',\r\n    /**\r\n     * Use a countdown that determines how much time each player has\r\n     * to fill out the text fields in one round of the game.\r\n     */\r\n    countdownEnds = 'countdownEnds',\r\n    /**\r\n     * The first player to click \"Finish round\" ends the round.\r\n     */\r\n    firstPlayerSubmits = 'firstPlayer',\r\n}\r\n\r\nexport interface GameConfig {\r\n    categories: string[];\r\n    durationOfCountdown: number;\r\n    endRoundMode: EndRoundMode;\r\n    letters: string[];\r\n    numberOfRounds: number;\r\n    scoringOptions: GameConfigScoringOptions;\r\n}\r\n\r\nexport interface StoredRunningGameInfo {\r\n    /** Version 4 UUID */\r\n    gameId: string;\r\n    /** UNIX timestamp */\r\n    idCreationTimestamp: number;\r\n    isPlayerAdmin: boolean;\r\n}\r\n\r\n/**\r\n * Represents a player's input for one category in one round of the game.\r\n */\r\nexport interface PlayerInput {\r\n    /** The points the player gains with this input if it is valid */\r\n    points: number;\r\n    /** Number of \"creative\" stars awarded by other players. Each player can award one star per answer */\r\n    stars: number;\r\n    /** The text input by the player */\r\n    text: string;\r\n    /** Is the input valid or was it rejected by the other players */\r\n    valid: boolean;\r\n}\r\n\r\n/**\r\n * Holds the inputs for all players (key = player's id) for one round of the game.\r\n */\r\nexport type GameRound = Map<string, PlayerInput[]>;\r\n\r\n/**\r\n * Represents the evaluation of all players for one player's input for one category in one round of the game.\r\n * The players' ids are used as keys for the map. The value represents whether the input is valid.\r\n */\r\nexport type PlayerInputEvaluation = Map<string, boolean>;\r\n\r\n/**\r\n * Represents the evaluation of all players' inputs in one round of the game. The players' ids\r\n * are used as keys for the map. The array holds one PlayerInputEvaluation object for each category.\r\n */\r\nexport type GameRoundEvaluation = Map<string, PlayerInputEvaluation[]>;\r\n\r\n/**\r\n * Represents the user's evaluation of a player's input for a category.\r\n */\r\nexport interface EvaluationOfPlayerInput {\r\n    categoryIndex: number;\r\n    evaluatedPlayerId: string;\r\n    markedAsValid: boolean;\r\n}\r\n\r\n/**\r\n * Used to track which answers were marked by the player as creative (represented as star shaped toggle buttons).\r\n * This information is used to determine whether the player can mark a specific answer as creative or undo this decision.\r\n * `Key`: other player's id. `Value`: answers (represented by category index) marked creative.\r\n */\r\nexport type CreativeStarsAwardedByPlayer = Map<string, number[]>;\r\n\r\n/**\r\n * Represents a \"creative answer\" star that a player adds to or removes from another player's input.\r\n */\r\nexport interface PlayerInputMarkedCreativeStatus {\r\n    categoryIndex: number;\r\n    evaluatedPlayerId: string;\r\n    /**\r\n     * If `true`, then a star is added. `False` means a star is removed.\r\n     */\r\n    markedAsCreative: boolean;\r\n}\r\n\r\nexport interface EqualAnswersOfCategory {\r\n    /** category index */\r\n    c: number;\r\n    /** value = equal answers */\r\n    v: string[];\r\n}\r\n\r\n/**\r\n * Contains the names of the players with the same number of points.\r\n */\r\nexport interface GameResultsGroup {\r\n    playerNames: string[];\r\n    points: number;\r\n}\r\n\r\n/**\r\n * Player inputs that receive \"creative answer\" stars from other players\r\n * are displayed in a \"Hall of Fame\" at the end of the game.\r\n */\r\nexport interface HallOfFameEntry {\r\n    category: string;\r\n    playerName: string;\r\n    text: string;\r\n}\r\n","export const GAME_ID_LABEL = 'Spiel-ID';\r\nexport const NUMBER_OF_CATEGORIES_LABEL = 'Anzahl Kategorien';\r\nexport const NUMBER_OF_ROUNDS_LABEL = 'Anzahl Runden';\r\nexport const PLAYER_NAME_LABEL = 'Spielername';\r\n","import { Link } from '@material-ui/core';\r\nimport DirectionsRunIcon from '@material-ui/icons/DirectionsRun';\r\nimport React from 'react';\r\n\r\nimport styles from './RejoinRunningGameHint.module.css';\r\n\r\nexport enum RejoinRunningGameHintContext {\r\n    newgame = 'newgame',\r\n    joingame = 'joingame'\r\n}\r\n\r\ninterface RejoinRunningGameHintProps {\r\n    context: RejoinRunningGameHintContext;\r\n    rejoinRunningGame: () => void;\r\n}\r\nexport const RejoinRunningGameHint: React.FunctionComponent<RejoinRunningGameHintProps> = props => {\r\n    const condition = props.context === 'newgame' ? 'ein neues Spiel erstellst' : 'einem anderen Spiel beitrittst';\r\n    const hintText = `Du nimmst bereits an einem laufenden Spiel teil. Wenn du ${condition},\r\n    kannst du nicht mehr in das alte Spiel zurückkehren!`;\r\n\r\n    return (\r\n        <div className=\"material-card-style\">\r\n            <p className={styles.hint_text}>\r\n                <span className=\"rejoin-running-game-hint-highlighted\">Achtung: </span>\r\n                {hintText}\r\n            </p>\r\n            <Link\r\n                component=\"button\"\r\n                className={styles.rejoin_game_button}\r\n                onClick={props.rejoinRunningGame}\r\n            >\r\n                <DirectionsRunIcon />\r\n                Zurück ins laufende Spiel\r\n            </Link>\r\n        </div>\r\n    );\r\n};\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"hint_text\":\"RejoinRunningGameHint_hint_text__24Gb_\",\"rejoin_game_button\":\"RejoinRunningGameHint_rejoin_game_button__1Tob4\"};","import { MAX_NUMBER_OF_ROUNDS, MIN_NUMBER_OF_CATEGORIES, MIN_NUMBER_OF_ROUNDS, STANDARD_ALPHABET } from '../constants/game.constant';\r\nimport { makePluralIfCountIsNotOne } from './general.utils';\r\n\r\n\r\nexport const getInvalidNameError = (): string => {\r\n    return 'Du musst einen Spielernamen eingeben';\r\n};\r\n\r\nexport const getInvalidGameIdError = (): string => {\r\n    return 'Du musst eine Spiel-ID eingeben';\r\n};\r\n\r\nexport const getInvalidRoundsError = (): string => {\r\n    return `Die Anzahl an Runden muss zwischen ${MIN_NUMBER_OF_ROUNDS} und ${MAX_NUMBER_OF_ROUNDS} liegen`;\r\n};\r\n\r\nexport const getTooFewCategoriesError = (): string => {\r\n    return `Wähle mindestens ${MIN_NUMBER_OF_CATEGORIES} Kategorien aus. Zum Beispiel: Stadt, Land und Fluss/Gewässer`;\r\n};\r\n\r\nexport const getTooManyLettersExcludedError = (numberOfRounds: number): string => {\r\n    const round = makePluralIfCountIsNotOne(numberOfRounds, 'Runde', 'Runden'); \r\n    const maxNumberToExclude = STANDARD_ALPHABET.length - numberOfRounds;\r\n    return `Du hast zu viele Buchstaben ausgeschlossen! Bei ${numberOfRounds} ${round} darfst du maximal ${maxNumberToExclude} Buchstaben ausschließen`;\r\n};\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"add_category_button\":\"AddCustomCategory_add_category_button__3TBkN\",\"less_padding\":\"AddCustomCategory_less_padding__t9AWk\",\"dialog_min_width\":\"AddCustomCategory_dialog_min_width__3OgRe\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"chip\":\"ChipsArray_chip__3nVin\",\"chip_label\":\"ChipsArray_chip_label__Tjvqm\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"options_label\":\"NewGameOptionsPanel_options_label__21M5o\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"random_categories_button\":\"SelectRandomCategories_random_categories_button__888IJ\",\"dialog_title\":\"SelectRandomCategories_dialog_title__2q4PR\",\"dialog_min_width\":\"SelectRandomCategories_dialog_min_width__2rUfu\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"custom_fieldset\":\"NewGame_custom_fieldset__3bBUZ\",\"custom_fieldset_error\":\"NewGame_custom_fieldset_error__1fnFz\",\"custom_legend\":\"NewGame_custom_legend__2x34A\",\"radio_group\":\"NewGame_radio_group__1yiCz\",\"countdown_wrapper\":\"NewGame_countdown_wrapper__xLLcN\",\"countdown_input\":\"NewGame_countdown_input__1l49c\",\"too_many_letters_excluded_error\":\"NewGame_too_many_letters_excluded_error___H604\",\"too_few_categories_error\":\"NewGame_too_few_categories_error__iKaVK\",\"selected_categories_wrapper\":\"NewGame_selected_categories_wrapper__2RkmF\",\"no_categories_hint\":\"NewGame_no_categories_hint__Alg8s\",\"info_text\":\"NewGame_info_text__lHhBb\",\"jump_to_end_button\":\"NewGame_jump_to_end_button__2tXZ2\",\"jump_to_end_button_icon\":\"NewGame_jump_to_end_button_icon__1eUy8\",\"alert_snackbar\":\"NewGame_alert_snackbar__2NScL\"};","import Chip from '@material-ui/core/Chip';\r\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\r\nimport ChevronRightIcon from '@material-ui/icons/ChevronRight';\r\nimport DoneIcon from '@material-ui/icons/Done';\r\nimport React from 'react';\r\n\r\nimport styles from './ChipsArray.module.css';\r\n\r\nexport enum ChipType {\r\n    available = 'available',\r\n    selected = 'selected'\r\n}\r\n\r\nconst useStyles = makeStyles((theme: Theme) =>\r\n    createStyles({\r\n        root: {\r\n            display: 'flex',\r\n            justifyContent: 'center',\r\n            flexWrap: 'wrap',\r\n            padding: theme.spacing(0.5),\r\n        }\r\n    }),\r\n);\r\n\r\ninterface ChipsArrayProps {\r\n    chipsArray: string[];\r\n    chipType: ChipType;\r\n    removeChip: (chip: string) => void;\r\n}\r\n\r\nconst ChipsArray: React.FunctionComponent<ChipsArrayProps> = props => {\r\n    const classes = useStyles();\r\n    return (\r\n        <div className={classes.root} role=\"list\">\r\n            {props.chipsArray.map((chip, index) => (\r\n                <Chip\r\n                    key={`chip-to-${props.chipType}-${index}`}\r\n                    role=\"listitem\"\r\n                    classes={{ root: styles.chip, label: styles.chip_label }}\r\n                    color={props.chipType === 'selected' ? 'primary' : undefined}\r\n                    icon={props.chipType === 'selected' ? <DoneIcon /> : <ChevronRightIcon />}\r\n                    label={chip}\r\n                    onClick={() => props.removeChip(chip)}\r\n                />\r\n            ))}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default ChipsArray;\r\n","import { Button, Dialog, DialogActions, DialogContent, DialogContentText, IconButton, TextField } from '@material-ui/core';\r\nimport AddCircleOutlineIcon from '@material-ui/icons/AddCircleOutline';\r\nimport React, { FormEvent, useState } from 'react';\r\n\r\nimport styles from './AddCustomCategory.module.css';\r\n\r\nexport interface CustomCategoryDialogProps {\r\n    open: boolean;\r\n    onClose: (newCategory: string | null) => void;\r\n}\r\nconst CustomCategoryDialog: React.FunctionComponent<CustomCategoryDialogProps> = props => {\r\n    const { onClose, open } = props;\r\n    const [categoryInput, setCategoryInput] = useState('');\r\n    const [validateInputs, setValidateInputs] = useState(false);\r\n    const isCategoryInputInvalid = validateInputs && !categoryInput;\r\n\r\n    const handleEnter = () => {\r\n        setValidateInputs(false);\r\n        setCategoryInput('');\r\n    };\r\n    const handleClose = () => onClose(null);\r\n    const handleSubmit = (event: FormEvent) => {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        const trimmedCategoryInput = categoryInput.trim();\r\n        if (trimmedCategoryInput !== '') {\r\n            setValidateInputs(false);\r\n            onClose(trimmedCategoryInput);\r\n        } else {\r\n            setCategoryInput('');\r\n            setValidateInputs(true);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Dialog onEnter={handleEnter} onClose={handleClose} open={open}>\r\n            <form onSubmit={handleSubmit} className={styles.dialog_min_width} noValidate autoComplete=\"off\">\r\n                <DialogContent>\r\n                    <DialogContentText>Eigene Kategorie definieren</DialogContentText>\r\n                    <label htmlFor=\"new-category-input\" className=\"sr-only\">\r\n                        Neue Kategorie\r\n                    </label>\r\n                    <TextField\r\n                        autoFocus\r\n                        margin=\"dense\"\r\n                        fullWidth\r\n                        required\r\n                        value={categoryInput}\r\n                        error={isCategoryInputInvalid}\r\n                        helperText={isCategoryInputInvalid ? 'Kategorie eingeben' : ''}\r\n                        inputProps={{ id: 'new-category-input' }}\r\n                        onChange={event => setCategoryInput(event.target.value)}\r\n                    />\r\n                </DialogContent>\r\n                <DialogActions>\r\n                    <Button\r\n                        type=\"button\"\r\n                        onClick={handleClose}\r\n                    >Abbrechen</Button>\r\n                    <Button\r\n                        type=\"submit\"\r\n                        color=\"primary\"\r\n                    >Hinzufügen</Button>\r\n                </DialogActions>\r\n            </form>\r\n        </Dialog>\r\n    );\r\n};\r\n\r\ninterface AddCustomCategoryProps {\r\n    addCustomCategory: (newCategory: string) => void;\r\n}\r\nconst AddCustomCategory: React.FunctionComponent<AddCustomCategoryProps> = props => {\r\n    const [open, setOpen] = useState(false);\r\n\r\n    const handleClose = (newCategory: string | null) => {\r\n        setOpen(false);\r\n        if (newCategory) {\r\n            props.addCustomCategory(newCategory);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <React.Fragment>\r\n            <IconButton\r\n                className={styles.add_category_button}\r\n                size=\"small\"\r\n                title=\"Eigene Kategorie definieren\"\r\n                aria-label=\"Eigene Kategorie definieren\"\r\n                onClick={() => setOpen(true)}\r\n            >\r\n                <AddCircleOutlineIcon />\r\n            </IconButton>\r\n            <CustomCategoryDialog open={open} onClose={handleClose} />\r\n        </React.Fragment>\r\n    );\r\n};\r\n\r\nexport default AddCustomCategory;\r\n","import {\r\n    Button,\r\n    FormControl,\r\n    FormControlLabel,\r\n    FormHelperText,\r\n    FormLabel,\r\n    Input,\r\n    Radio,\r\n    RadioGroup,\r\n    Snackbar,\r\n    SnackbarContent,\r\n    TextField,\r\n} from '@material-ui/core';\r\nimport AddCircleIcon from '@material-ui/icons/AddCircle';\r\nimport KeyboardArrowDownIcon from '@material-ui/icons/KeyboardArrowDown';\r\nimport { xor } from 'lodash';\r\nimport React, { ChangeEvent, Component, Dispatch, FormEvent } from 'react';\r\nimport { LiveMessage } from 'react-aria-live';\r\nimport { connect } from 'react-redux';\r\nimport { RouteComponentProps } from 'react-router';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nimport AddCustomCategory from '../../components/AddCustomCategory/AddCustomCategory';\r\nimport ChipsArray, { ChipType } from '../../components/ChipsArray/ChipsArray';\r\nimport NewGameOptionsPanel from '../../components/NewGameOptionsPanel/NewGameOptionsPanel';\r\nimport {\r\n    RejoinRunningGameHint,\r\n    RejoinRunningGameHintContext,\r\n} from '../../components/RejoinRunningGameHint/RejoinRunningGameHint';\r\nimport { SectionHeader } from '../../components/SectionHeader/SectionHeader';\r\nimport SelectRandomCategories from '../../components/SelectRandomCategories/SelectRandomCategories';\r\nimport ToDashboardButton from '../../components/ToDashboardButton/ToDashboardButton';\r\nimport { PLAYER_NAME_MAX_LENGTH } from '../../constants/app.constant';\r\nimport {\r\n    AVAILABLE_CATEGORIES,\r\n    DEFAULT_DURATION_OF_COUNTDOWN,\r\n    DEFAULT_NUMBER_OF_ROUNDS,\r\n    MAX_NUMBER_OF_ROUNDS,\r\n    MIN_DURATION_OF_COUNTDOWN,\r\n    MIN_NUMBER_OF_CATEGORIES,\r\n    MIN_NUMBER_OF_ROUNDS,\r\n    STANDARD_ALPHABET,\r\n    STANDARD_CATEGORIES,\r\n    STANDARD_EXCLUDED_LETTERS,\r\n} from '../../constants/game.constant';\r\nimport { NUMBER_OF_ROUNDS_LABEL, PLAYER_NAME_LABEL } from '../../constants/text.constant';\r\nimport { EndRoundMode, GameConfigScoringOptions } from '../../models/game.interface';\r\nimport { PlayerInfo } from '../../models/player.interface';\r\nimport { AppAction, prepareRejoiningGame, setDataForNewGame, SetDataForNewGamePayload } from '../../store/app.actions';\r\nimport { AppState } from '../../store/app.reducer';\r\nimport {\r\n    getInvalidNameError,\r\n    getInvalidRoundsError,\r\n    getTooFewCategoriesError,\r\n    getTooManyLettersExcludedError,\r\n} from '../../utils/error-text.util';\r\nimport { getRandomCategories, getRandomLetters } from '../../utils/game.utils';\r\nimport { convertDateToUnixTimestamp } from '../../utils/general.utils';\r\nimport {\r\n    removeAllDataOfRunningGameFromLocalStorage,\r\n    setPlayerInfoInLocalStorage,\r\n    setRunningGameInfoInLocalStorage,\r\n} from '../../utils/local-storage.utils';\r\nimport styles from './NewGame.module.css';\r\n\r\nenum CategoryArray {\r\n    available = 'available',\r\n    selected = 'selected'\r\n}\r\n\r\ninterface NewGamePropsFromStore {\r\n    gameId: string | null;\r\n    playerIdCreationTimestamp: number;\r\n    playerInfo: PlayerInfo | null;\r\n}\r\ninterface NewGameDispatchProps {\r\n    onPrepareRejoiningGame: () => void;\r\n    onSetGameData: (payload: SetDataForNewGamePayload) => void;\r\n}\r\ninterface NewGameProps extends NewGamePropsFromStore, NewGameDispatchProps, RouteComponentProps { }\r\ninterface NewGameState {\r\n    a11yMessageAssertive: string;\r\n    a11yMessagePolite: string;\r\n    availableCategories: string[];\r\n    durationOfCountdown: number;\r\n    endRoundMode: EndRoundMode;\r\n    isNumberOfRoundsInputValid: boolean;\r\n    isSnackbarOpen: boolean;\r\n    lettersToExclude: string[];\r\n    nameInput: string;\r\n    numberOfRoundsInput: number;\r\n    scoringOptions: GameConfigScoringOptions;\r\n    selectedCategories: string[];\r\n    snackBarMessage: string;\r\n    validateInputs: boolean;\r\n}\r\n\r\nclass NewGame extends Component<NewGameProps, NewGameState> {\r\n    public state: NewGameState = {\r\n        a11yMessageAssertive: '',\r\n        a11yMessagePolite: '',\r\n        availableCategories: AVAILABLE_CATEGORIES,\r\n        durationOfCountdown: DEFAULT_DURATION_OF_COUNTDOWN,\r\n        endRoundMode: EndRoundMode.allPlayersSubmit,\r\n        isNumberOfRoundsInputValid: true,\r\n        isSnackbarOpen: false,\r\n        lettersToExclude: [...STANDARD_EXCLUDED_LETTERS],\r\n        nameInput: this.props.playerInfo ? this.props.playerInfo.name : '',\r\n        numberOfRoundsInput: DEFAULT_NUMBER_OF_ROUNDS,\r\n        selectedCategories: STANDARD_CATEGORIES,\r\n        scoringOptions: {\r\n            checkForDuplicates: true,\r\n            creativeAnswersExtraPoints: true,\r\n            onlyPlayerWithValidAnswer: true,\r\n        },\r\n        snackBarMessage: '',\r\n        validateInputs: false\r\n    };\r\n\r\n    private submitButton: React.RefObject<HTMLButtonElement>;\r\n\r\n    constructor(props: NewGameProps) {\r\n        super(props);\r\n        this.submitButton = React.createRef();\r\n    }\r\n\r\n    public render() {\r\n        const playerNameAriaLabel = `${PLAYER_NAME_LABEL} (maximal ${PLAYER_NAME_MAX_LENGTH} Zeichen)`;\r\n        const playerNameVisibleLabel = `${PLAYER_NAME_LABEL} (max. ${PLAYER_NAME_MAX_LENGTH} Zeichen)`;\r\n        const numberOfRoundsAriaLabel = `${NUMBER_OF_ROUNDS_LABEL} (maximal ${MAX_NUMBER_OF_ROUNDS})`;\r\n        const numberOfRoundsVisibleLabel = `${NUMBER_OF_ROUNDS_LABEL} (max. ${MAX_NUMBER_OF_ROUNDS})`;\r\n        const maxNumberOfCategories = this.state.availableCategories.length + this.state.selectedCategories.length;\r\n        const isNameInvalid = this.state.validateInputs && !this.state.nameInput;\r\n        const isNumberOfRoundsInvalid = this.state.validateInputs && !this.state.isNumberOfRoundsInputValid;\r\n        const isNumberOfCategoriesInvalid = this.state.validateInputs && this.state.selectedCategories.length < MIN_NUMBER_OF_CATEGORIES;\r\n        const areTooManyLettersExcluded = this.state.validateInputs && (STANDARD_ALPHABET.length - this.state.lettersToExclude.length < this.state.numberOfRoundsInput);\r\n        const tooFewCategoriesError = (\r\n            <FormHelperText className={'MuiFormHelperText-contained ' + styles.too_few_categories_error} error>\r\n                {getTooFewCategoriesError()}\r\n            </FormHelperText>\r\n        );\r\n        const tooManyLettersExcludedError = (\r\n            <FormHelperText className={'MuiFormHelperText-contained ' + styles.too_many_letters_excluded_error} error>\r\n                {getTooManyLettersExcludedError(this.state.numberOfRoundsInput)}\r\n            </FormHelperText>\r\n        );\r\n        const noCategoriesSelected = <div className={styles.no_categories_hint}>Keine Kategorien ausgewählt</div>;\r\n        const noCategoriesAvailable = <div className={styles.no_categories_hint}>Keine weiteren Kategorien verfügbar</div>;\r\n        const newGameForm = (\r\n            <form onSubmit={this.handleSubmit} className=\"app-form\" noValidate autoComplete=\"off\">\r\n                <label htmlFor=\"player-name-input\" className=\"sr-only\">{playerNameAriaLabel}</label>\r\n                <TextField\r\n                    name=\"nameInput\"\r\n                    label={playerNameVisibleLabel}\r\n                    value={this.state.nameInput}\r\n                    className=\"app-form-input\"\r\n                    variant=\"outlined\"\r\n                    fullWidth\r\n                    required\r\n                    autoFocus\r\n                    error={isNameInvalid}\r\n                    helperText={isNameInvalid ? getInvalidNameError() : ''}\r\n                    inputProps={{\r\n                        id: 'player-name-input',\r\n                        autoComplete: 'nickname',\r\n                        maxLength: PLAYER_NAME_MAX_LENGTH\r\n                    }}\r\n                    onChange={this.handleNameInputChange}\r\n                />\r\n                <label htmlFor=\"number-of-rounds-input\" className=\"sr-only\">{numberOfRoundsAriaLabel}</label>\r\n                <TextField\r\n                    name=\"numberOfRoundsInput\"\r\n                    label={numberOfRoundsVisibleLabel}\r\n                    type=\"number\"\r\n                    value={this.state.numberOfRoundsInput}\r\n                    className=\"app-form-input\"\r\n                    variant=\"outlined\"\r\n                    fullWidth\r\n                    required\r\n                    error={isNumberOfRoundsInvalid}\r\n                    helperText={isNumberOfRoundsInvalid ? getInvalidRoundsError() : ''}\r\n                    inputProps={{\r\n                        id: 'number-of-rounds-input',\r\n                        min: MIN_NUMBER_OF_ROUNDS,\r\n                        max: MAX_NUMBER_OF_ROUNDS\r\n                    }}\r\n                    onChange={this.handleNumberOfRoundsInputChange}\r\n                />\r\n                <FormControl component=\"fieldset\" classes={{ root: styles.custom_fieldset }}>\r\n                    <FormLabel\r\n                        component=\"legend\"\r\n                        className={styles.custom_legend}\r\n                    >\r\n                        Beenden der Runde durch\r\n                    </FormLabel>\r\n                    <RadioGroup\r\n                        className={styles.radio_group}\r\n                        name=\"usecountdown\"\r\n                        value={this.state.endRoundMode}\r\n                        onChange={this.handleUseCountdownChange}\r\n                    >\r\n                        <FormControlLabel\r\n                            value={EndRoundMode.allPlayersSubmit}\r\n                            control={<Radio color=\"primary\" />}\r\n                            label=\"Alle Spielenden gemeinsam\"\r\n                        />\r\n                        <FormControlLabel\r\n                            value={EndRoundMode.firstPlayerSubmits}\r\n                            control={<Radio color=\"primary\" />}\r\n                            label=\"Schnellster Spieler\"\r\n                        />\r\n                        <div className={styles.countdown_wrapper}>\r\n                            <FormControlLabel\r\n                                value={EndRoundMode.countdownEnds}\r\n                                control={<Radio color=\"primary\" />}\r\n                                label=\"Countdown (Sekunden)\"\r\n                            />\r\n                            <Input\r\n                                type=\"number\"\r\n                                value={this.state.durationOfCountdown}\r\n                                className={styles.countdown_input}\r\n                                disabled={this.state.endRoundMode !== EndRoundMode.countdownEnds}\r\n                                inputProps={{ 'aria-label': 'Dauer des Countdowns', 'min': MIN_DURATION_OF_COUNTDOWN }}\r\n                                onChange={this.handleCountdownInputChange}\r\n                            />\r\n                        </div>\r\n                    </RadioGroup>\r\n                </FormControl>\r\n                <NewGameOptionsPanel\r\n                    lettersToExclude={this.state.lettersToExclude}\r\n                    scoringOptions={this.state.scoringOptions}\r\n                    handleGameOptionChange={this.handleGameOptionChange}\r\n                    handleLetterToExcludeChange={this.handleLetterToExcludeChange}\r\n                />\r\n                {areTooManyLettersExcluded && !isNumberOfRoundsInvalid ? tooManyLettersExcludedError : null}\r\n                <div className={styles.info_text} tabIndex={0}>\r\n                    Klicke auf eine Kategorie in der Liste „Ausgewählte Kategorien“, um diese aus der Liste zu entfernen.\r\n                    Die darunter liegende Liste „Verfügbare Kategorien“ enthält die nicht ausgewählten Kategorien, welche\r\n                    durch Klick aus der Liste entfernt und der Liste „Ausgewählte Kategorien“ hinzugefügt werden.\r\n                </div>\r\n                <div className={styles.selected_categories_wrapper}>\r\n                    <SelectRandomCategories\r\n                        maxNumberOfCategories={maxNumberOfCategories}\r\n                        selectCategoriesRandomly={this.selectCategoriesRandomly}\r\n                    />\r\n                    <FormControl\r\n                        component=\"fieldset\"\r\n                        classes={{ root: isNumberOfCategoriesInvalid ? styles.custom_fieldset_error : styles.custom_fieldset }}\r\n                    >\r\n                        <FormLabel\r\n                            component=\"legend\"\r\n                            className={styles.custom_legend}\r\n                        >\r\n                            Ausgewählte Kategorien (<abbr title=\"mindestens\">mind.</abbr> {MIN_NUMBER_OF_CATEGORIES})\r\n                        </FormLabel>\r\n                        {this.state.selectedCategories.length > 0 ? (\r\n                            <ChipsArray\r\n                                chipsArray={this.state.selectedCategories}\r\n                                chipType={ChipType.selected}\r\n                                removeChip={(chipToRemove) => this.updateCategoryArrays(chipToRemove, CategoryArray.selected)}\r\n                            />\r\n                        ) : noCategoriesSelected}\r\n                    </FormControl>\r\n                    <AddCustomCategory addCustomCategory={this.addCustomCategory} />\r\n                </div>\r\n                {isNumberOfCategoriesInvalid ? tooFewCategoriesError : null}\r\n                <button\r\n                    type=\"button\"\r\n                    className={styles.jump_to_end_button}\r\n                    onClick={this.scrollToAndFocusSubmitButton}\r\n                >\r\n                    <span>Zum Formularende springen</span>\r\n                    <KeyboardArrowDownIcon className={styles.jump_to_end_button_icon} />\r\n                </button>\r\n                <FormControl\r\n                    component=\"fieldset\"\r\n                    classes={{ root: styles.custom_fieldset }}\r\n                >\r\n                    <FormLabel\r\n                        component=\"legend\"\r\n                        className={styles.custom_legend}\r\n                    >\r\n                        Verfügbare Kategorien\r\n                        <span className=\"sr-only\">\r\n                            Klicke auf eine Kategorie, um diese der Liste\r\n                            der ausgewählten Kategorien hinzuzufügen.\r\n                        </span>\r\n                    </FormLabel>\r\n                    {this.state.availableCategories.length > 0 ? (\r\n                        <ChipsArray\r\n                            chipsArray={this.state.availableCategories}\r\n                            chipType={ChipType.available}\r\n                            removeChip={(chipToRemove) => this.updateCategoryArrays(chipToRemove, CategoryArray.available)}\r\n                        />\r\n                    ) : noCategoriesAvailable}\r\n                </FormControl>\r\n                <div className=\"button-wrapper add-margin-top\">\r\n                    <Button\r\n                        type=\"submit\"\r\n                        color=\"primary\"\r\n                        variant=\"contained\"\r\n                        size=\"large\"\r\n                        startIcon={<AddCircleIcon />}\r\n                        ref={this.submitButton}\r\n                    >Spiel erstellen</Button>\r\n                </div>\r\n            </form>\r\n        );\r\n        const rejoinRunningGameElement = (\r\n            <RejoinRunningGameHint\r\n                context={RejoinRunningGameHintContext.newgame}\r\n                rejoinRunningGame={this.rejoinRunningGame}\r\n            />\r\n        );\r\n        return (\r\n            <div className=\"main-content-wrapper\">\r\n                {this.props.gameId ? rejoinRunningGameElement : null}\r\n                <div className=\"material-card-style\">\r\n                    <SectionHeader text=\"Neues Spiel\" />\r\n                    {newGameForm}\r\n                </div>\r\n                <ToDashboardButton onReturnToDashboard={this.returnToDashboard} />\r\n                <Snackbar\r\n                    anchorOrigin={{ vertical: 'bottom', horizontal: 'left' }}\r\n                    open={this.state.isSnackbarOpen}\r\n                    autoHideDuration={3000}\r\n                    onClose={this.handleSnackBarClose}\r\n                >\r\n                    <SnackbarContent\r\n                        classes={{ root: styles.alert_snackbar }}\r\n                        message={this.state.snackBarMessage}\r\n                    ></SnackbarContent>\r\n                </Snackbar>\r\n                <LiveMessage\r\n                    message={this.state.a11yMessageAssertive}\r\n                    aria-live=\"assertive\"\r\n                    clearOnUnmount=\"true\"\r\n                />\r\n                <LiveMessage\r\n                    message={this.state.a11yMessagePolite}\r\n                    aria-live=\"polite\"\r\n                    clearOnUnmount=\"true\"\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n\r\n    public componentDidUpdate(prevProps: NewGameProps) {\r\n        if (this.props.playerInfo && this.props.playerInfo !== prevProps.playerInfo) {\r\n            this.setState({ nameInput: this.props.playerInfo.name });\r\n        }\r\n    }\r\n\r\n    private handleNameInputChange = (event: ChangeEvent<HTMLInputElement>) => {\r\n        this.setState({ nameInput: event.target.value });\r\n    }\r\n\r\n    private handleNumberOfRoundsInputChange = (event: ChangeEvent<HTMLInputElement>) => {\r\n        const value = +event.target.value;\r\n        const isNumberOfRoundsInputValid = value >= MIN_NUMBER_OF_ROUNDS && value <= MAX_NUMBER_OF_ROUNDS;\r\n        this.setState({ isNumberOfRoundsInputValid, numberOfRoundsInput: value });\r\n    }\r\n\r\n    private handleGameOptionChange = (event: ChangeEvent<HTMLInputElement>) => {\r\n        this.setState({\r\n            scoringOptions: {\r\n                ...this.state.scoringOptions,\r\n                [event.target.name]: event.target.checked\r\n            }\r\n        });\r\n    }\r\n\r\n    private handleCountdownInputChange = (event: ChangeEvent<HTMLInputElement>) => {\r\n        this.setState({ durationOfCountdown: +event.target.value });\r\n    }\r\n\r\n    private handleLetterToExcludeChange = (event: ChangeEvent<HTMLInputElement>, letter: string) => {\r\n        const { lettersToExclude } = this.state;\r\n        const newLettersToExclude = event.target.checked ? [...lettersToExclude, letter] : lettersToExclude.filter(l => l !== letter);\r\n        this.setState({ lettersToExclude: newLettersToExclude });\r\n    }\r\n\r\n    private handleUseCountdownChange = (event: ChangeEvent<HTMLInputElement>) => {\r\n        this.setState({ endRoundMode: event.target.value as EndRoundMode });\r\n    };\r\n\r\n    private selectCategoriesRandomly = (numberOfCategories: number, retainSelection: boolean) => {\r\n        const categoryPool = [...this.state.availableCategories, ...this.state.selectedCategories];\r\n        const selectedCategories = getRandomCategories(\r\n            numberOfCategories, categoryPool, retainSelection ? this.state.selectedCategories : []\r\n        );\r\n        const availableCategories = categoryPool.filter(c => !selectedCategories.includes(c)).sort();\r\n        this.setState({ availableCategories, selectedCategories });\r\n        // Trigger a11y message after short timeout so that screen reader reads new position of focus first.\r\n        setTimeout(() => {\r\n            const a11yMessagePolite = `Es wurden ${numberOfCategories} Kategorien zufällig ausgewählt.`;\r\n            this.setState({ a11yMessagePolite });\r\n        }, 500);\r\n    }\r\n\r\n    private updateCategoryArrays = (chipToRemove: string, removeFromArray: CategoryArray) => {\r\n        let newSelectedCategories: string[];\r\n        let newAvailableCategories: string[];\r\n        let a11yMessagePolite: string;\r\n        if (removeFromArray === CategoryArray.selected) {\r\n            newSelectedCategories = this.state.selectedCategories.filter(category => category !== chipToRemove);\r\n            newAvailableCategories = [...this.state.availableCategories];\r\n            newAvailableCategories.push(chipToRemove);\r\n            a11yMessagePolite = `Kategorie ${chipToRemove} wurde aus der Liste der ausgewählten Kategorien entfernt.`;\r\n        } else {\r\n            newAvailableCategories = this.state.availableCategories.filter(category => category !== chipToRemove);\r\n            newSelectedCategories = [...this.state.selectedCategories];\r\n            newSelectedCategories.push(chipToRemove);\r\n            a11yMessagePolite = `Kategorie ${chipToRemove} wurde der Liste der ausgewählten Kategorien hinzugefügt.`;\r\n        }\r\n        this.setState({\r\n            a11yMessagePolite,\r\n            availableCategories: newAvailableCategories.sort(),\r\n            selectedCategories: newSelectedCategories\r\n        });\r\n    }\r\n\r\n    private addCustomCategory = (newCategory: string) => {\r\n        this.setState({ selectedCategories: [...this.state.selectedCategories, newCategory] });\r\n        // Trigger a11y message after short timeout so that screen reader reads new position of focus first.\r\n        setTimeout(() => {\r\n            const a11yMessagePolite = `Die Kategorie ${newCategory} wurde der Liste der ausgewählten Kategorien hinzugefügt.`;\r\n            this.setState({ a11yMessagePolite });\r\n        }, 500);\r\n    }\r\n\r\n    private scrollToAndFocusSubmitButton = () => {\r\n        this.submitButton.current?.scrollIntoView();\r\n        this.submitButton.current?.focus();\r\n    }\r\n\r\n    private handleSubmit = (event: FormEvent) => {\r\n        event.preventDefault();\r\n        if (this.isReadyToStartGame()) {\r\n            this.startNewGame();\r\n        } else {\r\n            this.setState({ nameInput: this.state.nameInput.trim(), validateInputs: true });\r\n        }\r\n    }\r\n\r\n    private isReadyToStartGame = (): boolean => {\r\n        const { isNumberOfRoundsInputValid, lettersToExclude, numberOfRoundsInput, selectedCategories } = this.state;\r\n        if (!this.state.nameInput.trim()) {\r\n            this.alertUser(getInvalidNameError());\r\n            return false;\r\n        }\r\n        if (!isNumberOfRoundsInputValid) {\r\n            this.alertUser(getInvalidRoundsError());\r\n            return false;\r\n        }\r\n        if (selectedCategories.length < MIN_NUMBER_OF_CATEGORIES) {\r\n            this.alertUser(getTooFewCategoriesError());\r\n            return false;\r\n        }\r\n        if (STANDARD_ALPHABET.length - lettersToExclude.length < numberOfRoundsInput) {\r\n            this.alertUser(getTooManyLettersExcludedError(numberOfRoundsInput));\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private alertUser = (message: string) => this.setState(\r\n        { a11yMessageAssertive: message, isSnackbarOpen: true, snackBarMessage: message }\r\n    );\r\n\r\n    private handleSnackBarClose = () => this.setState({ isSnackbarOpen: false });\r\n\r\n    private startNewGame = () => {\r\n        const playerInfo = this.props.playerInfo as PlayerInfo;\r\n        const idCreationTimestamp = this.props.playerIdCreationTimestamp;\r\n        const { durationOfCountdown, endRoundMode, nameInput, numberOfRoundsInput, scoringOptions, selectedCategories } = this.state;\r\n        const gameId = uuidv4(); // ⇨ e.g. '9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d'\r\n        removeAllDataOfRunningGameFromLocalStorage();\r\n        setPlayerInfoInLocalStorage({ id: playerInfo.id, idCreationTimestamp, name: nameInput.trim() });\r\n        setRunningGameInfoInLocalStorage({ gameId, idCreationTimestamp: convertDateToUnixTimestamp(new Date()), isPlayerAdmin: true });\r\n        this.props.onSetGameData({\r\n            gameConfig: {\r\n                categories: selectedCategories,\r\n                durationOfCountdown,\r\n                endRoundMode,\r\n                letters: getRandomLetters(numberOfRoundsInput, xor(STANDARD_ALPHABET, this.state.lettersToExclude)),\r\n                numberOfRounds: numberOfRoundsInput,\r\n                scoringOptions,\r\n            },\r\n            gameId,\r\n            isRejoiningGame: false,\r\n            playerInfo: {\r\n                id: playerInfo.id,\r\n                isAdmin: true,\r\n                name: nameInput.trim()\r\n            }\r\n        });\r\n        this.props.history.push('/play');\r\n    }\r\n\r\n    private rejoinRunningGame = () => {\r\n        this.props.onPrepareRejoiningGame();\r\n        this.props.history.push('/play');\r\n    }\r\n\r\n    private returnToDashboard = () => {\r\n        this.props.history.push('/');\r\n    }\r\n}\r\n\r\nconst mapStateToProps = (state: AppState): NewGamePropsFromStore => {\r\n    return {\r\n        gameId: state.gameId,\r\n        playerIdCreationTimestamp: state.playerIdCreationTimestamp,\r\n        playerInfo: state.playerInfo\r\n    };\r\n};\r\nconst mapDispatchToProps = (dispatch: Dispatch<AppAction>): NewGameDispatchProps => {\r\n    return {\r\n        onPrepareRejoiningGame: () => dispatch(prepareRejoiningGame()),\r\n        onSetGameData: (payload: SetDataForNewGamePayload) => dispatch(setDataForNewGame(payload))\r\n    };\r\n};\r\nexport default connect(mapStateToProps, mapDispatchToProps)(NewGame);\r\n","import {\r\n    Accordion,\r\n    AccordionDetails,\r\n    AccordionSummary,\r\n    Checkbox,\r\n    Divider,\r\n    FormControl,\r\n    FormControlLabel,\r\n    FormGroup,\r\n    FormLabel,\r\n} from '@material-ui/core';\r\nimport ExpandMoreIcon from '@material-ui/icons/ExpandMore';\r\nimport React, { ChangeEvent } from 'react';\r\n\r\nimport { GAME_OPTION_LABEL, STANDARD_ALPHABET } from '../../constants/game.constant';\r\nimport { GameConfigScoringOptions, GameOption } from '../../models/game.interface';\r\nimport styles from './NewGameOptionsPanel.module.css';\r\n\r\ninterface NewGameOptionsPanelProps {\r\n    lettersToExclude: string[];\r\n    scoringOptions: GameConfigScoringOptions;\r\n    handleGameOptionChange: (event: ChangeEvent<HTMLInputElement>) => void;\r\n    handleLetterToExcludeChange: (event: ChangeEvent<HTMLInputElement>, letter: string) => void;\r\n}\r\n\r\nconst NewGameOptionsPanel: React.FunctionComponent<NewGameOptionsPanelProps> = props => {\r\n    return (\r\n        <Accordion className=\"new-game-expansion-panel\">\r\n            <AccordionSummary\r\n                expandIcon={<ExpandMoreIcon />}\r\n                aria-controls=\"panel1a-content\"\r\n                id=\"panel1a-header\"\r\n            >\r\n                Weitere Optionen\r\n            </AccordionSummary>\r\n            <AccordionDetails>\r\n                <FormGroup className=\"game-options-list\">\r\n                    <FormControlLabel\r\n                        control={\r\n                            <Checkbox\r\n                                checked={props.scoringOptions.checkForDuplicates}\r\n                                name={GameOption.checkForDuplicates}\r\n                                color=\"primary\"\r\n                                onChange={props.handleGameOptionChange}\r\n                            />\r\n                        }\r\n                        label={GAME_OPTION_LABEL.checkForDuplicates}\r\n                    />\r\n                    <FormControlLabel\r\n                        control={\r\n                            <Checkbox\r\n                                checked={props.scoringOptions.onlyPlayerWithValidAnswer}\r\n                                name={GameOption.onlyPlayerWithValidAnswer}\r\n                                color=\"primary\"\r\n                                onChange={props.handleGameOptionChange}\r\n                            />\r\n                        }\r\n                        label={GAME_OPTION_LABEL.onlyPlayerWithValidAnswer}\r\n                    />\r\n                    <FormControlLabel\r\n                        control={\r\n                            <Checkbox\r\n                                checked={props.scoringOptions.creativeAnswersExtraPoints}\r\n                                name={GameOption.creativeAnswersExtraPoints}\r\n                                color=\"primary\"\r\n                                onChange={props.handleGameOptionChange}\r\n                            />\r\n                        }\r\n                        label={GAME_OPTION_LABEL.creativeAnswersExtraPoints}\r\n                    />\r\n                </FormGroup>\r\n                <Divider />\r\n                <FormControl component=\"fieldset\">\r\n                    <FormLabel\r\n                        component=\"legend\"\r\n                        className={styles.options_label}\r\n                    >\r\n                        Folgende Buchstaben ausschließen:\r\n                    </FormLabel>\r\n                    <FormGroup row className=\"letters-to-exclude\">\r\n                        {STANDARD_ALPHABET.map((letter, letterIndex) => (\r\n                            <FormControlLabel\r\n                                key={`slf-letters-to-exclude-${letterIndex}`}\r\n                                control={\r\n                                    <Checkbox\r\n                                        checked={props.lettersToExclude.includes(letter)}\r\n                                        color=\"primary\"\r\n                                        onChange={(event) => props.handleLetterToExcludeChange(event, letter)}\r\n                                    />\r\n                                }\r\n                                label={letter}\r\n                            />\r\n                        ))}\r\n                    </FormGroup>\r\n                </FormControl>\r\n            </AccordionDetails>\r\n        </Accordion>\r\n    );\r\n};\r\n\r\nexport default NewGameOptionsPanel;\r\n","import {\r\n    Button,\r\n    Checkbox,\r\n    Dialog,\r\n    DialogActions,\r\n    DialogContent,\r\n    DialogContentText,\r\n    FormControlLabel,\r\n    IconButton,\r\n    makeStyles,\r\n    TextField,\r\n} from '@material-ui/core';\r\nimport FlipCameraAndroidIcon from '@material-ui/icons/FlipCameraAndroid';\r\nimport React, { ChangeEvent, FormEvent, useState } from 'react';\r\n\r\nimport { MIN_NUMBER_OF_CATEGORIES } from '../../constants/game.constant';\r\nimport { NUMBER_OF_CATEGORIES_LABEL } from '../../constants/text.constant';\r\nimport styles from './SelectRandomCategories.module.css';\r\n\r\nconst useStyles = makeStyles(() => ({\r\n    label: {\r\n        fontSize: '0.85rem',\r\n    }\r\n}));\r\n\r\nexport interface SelectRandomCategoriesDialogProps {\r\n    maxNumberOfCategories: number;\r\n    open: boolean;\r\n    onClose: (numberOfCategories: number | null, retainSelection?: boolean) => void;\r\n}\r\nconst SelectRandomCategoriesDialog: React.FunctionComponent<SelectRandomCategoriesDialogProps> = props => {\r\n    const checkboxLabelClasses = useStyles();\r\n    const { onClose, open } = props;\r\n    const [isNumberOfCategoriesInputValid, setIsNumberOfCategoriesInputValid] = useState(true);\r\n    const [numberOfCategoriesInput, setNumberOfCategoriesInput] = useState(MIN_NUMBER_OF_CATEGORIES);\r\n    const [validateInputs, setValidateInputs] = useState(false);\r\n    const [retainSelection, setRetainSelection] = useState(false);\r\n    const numberOfCategoriesAriaLabel = `${NUMBER_OF_CATEGORIES_LABEL} (mindestens ${MIN_NUMBER_OF_CATEGORIES}, maximal ${props.maxNumberOfCategories})`;\r\n    const numberOfCategoriesVisibleLabel = `${NUMBER_OF_CATEGORIES_LABEL} (${MIN_NUMBER_OF_CATEGORIES}-${props.maxNumberOfCategories})`;\r\n\r\n    const handleNumberOfCategoriesInputChange = (event: ChangeEvent<HTMLInputElement>) => {\r\n        const value = +event.target.value;\r\n        setNumberOfCategoriesInput(value);\r\n        setIsNumberOfCategoriesInputValid(value >= MIN_NUMBER_OF_CATEGORIES && value <= props.maxNumberOfCategories);\r\n    };\r\n    const handleRetainSelectionOptionChange = (event: ChangeEvent<HTMLInputElement>) => {\r\n        setRetainSelection(event.target.checked);\r\n    };\r\n    const handleClose = () => onClose(null);\r\n    const handleSubmit = (event: FormEvent) => {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        if (isNumberOfCategoriesInputValid) {\r\n            setValidateInputs(false);\r\n            onClose(numberOfCategoriesInput, retainSelection);\r\n        } else {\r\n            setValidateInputs(true);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Dialog onClose={handleClose} open={open}>\r\n            <form onSubmit={handleSubmit} className={styles.dialog_min_width} noValidate autoComplete=\"off\">\r\n                <DialogContent>\r\n                    <DialogContentText className={styles.dialog_title}>\r\n                        Kategorien zufällig auswählen\r\n                    </DialogContentText>\r\n                    <label htmlFor=\"number-of-categories-input\" className=\"sr-only\">\r\n                        {numberOfCategoriesAriaLabel}\r\n                    </label>\r\n                    <TextField\r\n                        name=\"numberOfRoundsInput\"\r\n                        label={numberOfCategoriesVisibleLabel}\r\n                        type=\"number\"\r\n                        value={numberOfCategoriesInput}\r\n                        variant=\"outlined\"\r\n                        fullWidth\r\n                        required\r\n                        autoFocus\r\n                        error={validateInputs && !isNumberOfCategoriesInputValid}\r\n                        helperText={validateInputs && !isNumberOfCategoriesInputValid ? 'Du musst eine gültige Anzahl eingeben' : ''}\r\n                        inputProps={{\r\n                            id: 'number-of-categories-input',\r\n                            min: MIN_NUMBER_OF_CATEGORIES,\r\n                            max: props.maxNumberOfCategories\r\n                        }}\r\n                        onChange={handleNumberOfCategoriesInputChange}\r\n                    />\r\n                    <FormControlLabel\r\n                        classes={checkboxLabelClasses}\r\n                        control={\r\n                            <Checkbox\r\n                                checked={retainSelection}\r\n                                name=\"retainSelection\"\r\n                                color=\"primary\"\r\n                                onChange={handleRetainSelectionOptionChange}\r\n                            />\r\n                        }\r\n                        label=\"Inklusive bereits ausgewählter Kategorien\"\r\n                    />\r\n                </DialogContent>\r\n                <DialogActions>\r\n                    <Button\r\n                        type=\"button\"\r\n                        onClick={handleClose}\r\n                    >Abbrechen</Button>\r\n                    <Button\r\n                        type=\"submit\"\r\n                        color=\"primary\"\r\n                    >Auswählen</Button>\r\n                </DialogActions>\r\n            </form>\r\n        </Dialog>\r\n    );\r\n};\r\n\r\ninterface SelectRandomCategoriesProps {\r\n    maxNumberOfCategories: number;\r\n    selectCategoriesRandomly: (numberOfCategories: number, retainSelection: boolean) => void;\r\n}\r\nconst SelectRandomCategories: React.FunctionComponent<SelectRandomCategoriesProps> = props => {\r\n    const [open, setOpen] = useState(false);\r\n\r\n    const handleClose = (numberOfCategories: number | null, retainSelection?: boolean) => {\r\n        setOpen(false);\r\n        if (numberOfCategories && retainSelection !== undefined) {\r\n            props.selectCategoriesRandomly(numberOfCategories, retainSelection);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <React.Fragment>\r\n            <IconButton\r\n                className={styles.random_categories_button}\r\n                size=\"small\"\r\n                title=\"Kategorien zufällig auswählen\"\r\n                aria-label=\"Kategorien zufällig auswählen\"\r\n                onClick={() => setOpen(true)}\r\n            >\r\n                <FlipCameraAndroidIcon />\r\n            </IconButton>\r\n            <SelectRandomCategoriesDialog\r\n                maxNumberOfCategories={props.maxNumberOfCategories}\r\n                open={open}\r\n                onClose={handleClose}\r\n            />\r\n        </React.Fragment>\r\n    );\r\n};\r\n\r\nexport default SelectRandomCategories;\r\n"],"sourceRoot":""}